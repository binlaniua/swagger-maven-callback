import * as prettier from 'prettier';

export interface Swagger2Definition {
  $ref?: string;
  allOf?: Swagger2Definition[];
  description?: string;
  enum?: string[];
  format?: string;
  items?: Swagger2Definition;
  oneOf?: Swagger2Definition[];
  properties?: { [index: string]: Swagger2Definition };
  additionalProperties?: boolean | Swagger2Definition;
  required?: string[];
  type?: 'array' | 'boolean' | 'integer' | 'number' | 'object' | 'string';
}

export interface Swagger2Parameter {
  name: string;
  in: 'body' | 'query' | 'path';
  description: string;
  required: boolean;
  schema?: { $ref?: string; type?: string };
  type?: string;
  pattern?: string;
  items?: {
    type?: string;
    refs?: string;
  };
}

export interface Swagger2Response {
  description: string;
  schema?: {
    type?: string;
    $ref?: string;
    items?: {
      type?: string;
      $ref?: string;
    };
  };
}

export interface Swagger2Method {
  tags: Array<string>;
  summary?: string;
  parameters?: Array<Swagger2Parameter>;
  responses: {
    [code: string]: Swagger2Response;
  };
}

export interface Swagger2 {
  info: {
    title: string;
    version: string;
  };
  definitions: {
    [index: string]: Swagger2Definition;
  };
  paths: {
    [url: string]: {
      [method: string]: Swagger2Method;
    };
  };
}

export interface Swagger2Options {
  camelcase?: boolean;
  wrapper?: string | false;
  injectWarning?: boolean;
}

export const warningMessage = `
/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */
`;

// Primitives only!
const TYPES: { [index: string]: string } = {
  string: 'string',
  integer: 'number',
  number: 'number',
};

function capitalize(str: string): string {
  return `${str[0].toUpperCase()}${str.slice(1)}`;
}

function camelCase(name: string): string {
  return name.replace(/(-|_|\.|\s)+\w/g, (letter): string =>
    letter.toUpperCase().replace(/[^0-9a-z]/gi, '')
  );
}

function sanitize(name: string): string {
  return name.includes('-') ? `'${name}'` : name;
}

function spacesToUnderscores(name: string): string {
  return name.replace(/\s/g, '_');
}

function parse(spec: Swagger2, options: Swagger2Options = {}): string {
  // 使用info的title作为namespace
  const wrapper = `declare namespace ${spec.info.title.replace(/\s|-|_/g, '')}`;
  const shouldCamelCase = options.camelcase || false;
  const shouldInsertWarning = options.injectWarning || false;

  const queue: [string, Swagger2Definition][] = [];

  const output: string[] = [];

  if (shouldInsertWarning) {
    output.push(warningMessage);
  }

  if (wrapper) {
    output.push(`${wrapper} {`);
  }

  const { definitions } = spec;

  function getRef(lookup: string): [string, Swagger2Definition] {
    const ID = lookup.replace('#/definitions/', '');
    const ref = definitions[ID];
    return [ID, ref];
  }

  // Returns primitive type, or 'object' or 'any'
  function getType(definition: Swagger2Definition, nestedName: string): string {
    const { $ref, items, type, ...value } = definition;

    const nextInterface = camelCase(nestedName); // if this becomes an interface, it’ll need to be camelCased

    const DEFAULT_TYPE = 'any';

    if ($ref) {
      const [refName, refProperties] = getRef($ref);
      const convertedRefName = spacesToUnderscores(refName);
      // If a shallow array interface, return that instead
      if (refProperties.items && refProperties.items.$ref) {
        return getType(refProperties, refName);
      }
      if (refProperties.type && TYPES[refProperties.type]) {
        return TYPES[refProperties.type];
      }
      return convertedRefName || DEFAULT_TYPE;
    }

    if (items && items.$ref) {
      const [refName] = getRef(items.$ref);
      return `${getType(items, refName)}[]`;
    }

    if (items && items.type) {
      // if an array, keep nesting
      if (items.type === 'array') {
        return `${getType(items, nestedName)}[]`;
      }
      // else if primitive, return type
      if (TYPES[items.type]) {
        return `${TYPES[items.type]}[]`;
      }
      // otherwise if this is an array of nested types, return that interface for later
      queue.push([nextInterface, items]);
      return `${nextInterface}[]`;
    }

    if (Array.isArray(value.oneOf)) {
      return value.oneOf.map((def): string => getType(def, '')).join(' | ');
    }

    if (value.properties) {
      // If this is a nested object, let’s add it to the stack for later
      queue.push([nextInterface, { $ref, items, type, ...value }]);
      return nextInterface;
    }

    if (type) {
      return TYPES[type] || type || DEFAULT_TYPE;
    }

    return DEFAULT_TYPE;
  }

  function buildNextInterface(): void {
    const nextObject = queue.pop();
    if (!nextObject) return; // Geez TypeScript it’s going to be OK
    const [ID, { allOf, properties, required, additionalProperties, type }] = nextObject;

    let allProperties = properties || {};
    const includes: string[] = [];

    // Include allOf, if specified
    if (Array.isArray(allOf)) {
      allOf.forEach((item): void => {
        // Add “implements“ if this references other items
        if (item.$ref) {
          const [refName] = getRef(item.$ref);
          includes.push(refName);
        } else if (item.properties) {
          allProperties = { ...allProperties, ...item.properties };
        }
      });
    }

    // If nothing’s here, let’s skip this one.
    if (
      !Object.keys(allProperties).length &&
      additionalProperties !== true &&
      type &&
      TYPES[type]
    ) {
      return;
    }
    // Open interface
    const isExtending = includes.length ? ` extends ${includes.join(', ')}` : '';

    output.push(
      `export interface ${
        shouldCamelCase ? camelCase(ID) : spacesToUnderscores(ID)
      }${isExtending} {`
    );

    // Populate interface
    Object.entries(allProperties).forEach(([key, value]): void => {
      const optional = !Array.isArray(required) || required.indexOf(key) === -1;
      const formattedKey = shouldCamelCase ? camelCase(key) : key;
      const name = `${sanitize(formattedKey)}${optional ? '?' : ''}`;
      const newID = `${ID}${capitalize(formattedKey)}`;
      const interfaceType = getType(value, newID);

      if (typeof value.description === 'string') {
        // Print out descriptions as jsdoc comments, but only if there’s something there (.*)
        output.push(`/**\n* ${value.description.replace(/\n$/, '').replace(/\n/g, '\n* ')}\n*/`);
      }

      // Handle enums in the same definition
      if (Array.isArray(value.enum)) {
        output.push(`${name}: ${value.enum.map(option => JSON.stringify(option)).join(' | ')};`);
        return;
      }

      output.push(`${name}: ${interfaceType};`);
    });

    if (additionalProperties) {
      if ((additionalProperties as boolean) === true) {
        output.push('[name: string]: any');
      }

      if ((additionalProperties as Swagger2Definition).type) {
        const interfaceType = getType(additionalProperties as Swagger2Definition, '');
        output.push(`[name: string]: ${interfaceType}`);
      }
    }

    // Close interface
    output.push('}');
  }

  // Begin parsing top-level entries
  Object.entries(definitions).forEach((entry): void => {
    // Ignore top-level array definitions
    if (entry[1].type === 'object') {
      queue.push(entry);
    }
  });
  queue.sort((a, b) => a[0].localeCompare(b[0]));
  while (queue.length > 0) {
    buildNextInterface();
  }

  //开始解析paths
  function methodOutputParse(u: string, m: string, method: Swagger2Method): string {
    u = u.replace(/^\//, ''); //移除第一个/
    const comments: Array<string> = [];
    //1. 构造方法名
    const methodName = u
      .split('/')
      .map((c, i) => {
        c = c.replace(/{|}/g, '');
        return i == 0 ? c : c.charAt(0).toUpperCase() + c.substr(1);
      })
      .join('');
    if (method.summary) {
      comments.push(method.summary);
    } else {
      comments.push(methodName);
    }
    //2. 构造入参
    const methodArgs: Array<string> = (method.parameters || []).map((o, i) => {
      comments.push(`@param ${o.name} ${o.description || ''}`);
      if (o.type) {
        if (o.type == 'array') {
          const gen = o.items ? (o.items.type ? o.items.type : getRef(o.items.refs as any)[0]) : '';
          return `${o.name} :Array<${gen}>`;
        }
        return `${o.name} :${o.type}`;
      } else if (o.schema) {
        return `${o.name} :${o.schema.type ? o.schema.type : getRef(o.schema?.$ref as string)[0]}`;
      } else {
        return `${o.name} :any`;
      }
    });
    //3. 默认只拿第一个返回的
    const firstResponse = method.responses[Object.keys(method.responses)[0]];
    comments.push(`@return ${firstResponse.description || ''}`);
    let methodResult = '';
    if (firstResponse.schema && firstResponse.schema.type) {
      if (firstResponse.schema.type == 'array') {
        const gen = firstResponse.schema.items
          ? firstResponse.schema.items.type
            ? firstResponse.schema.items.type
            : getRef(firstResponse.schema.items.$ref as any)[0]
          : '';
        methodResult = `Array<${gen}>`;
      } else if (firstResponse.schema.type) {
        methodResult = `${firstResponse.schema.type}`;
      } else if (firstResponse.schema.$ref) {
        methodResult = getRef(firstResponse.schema.$ref as any)[0];
      } else {
        methodResult = 'any';
      }
    } else if (firstResponse.schema) {
      methodResult = getRef(firstResponse.schema.$ref as string)[0];
    } else {
      methodResult = '';
    }
    return `
/**
 * ${comments.join('\n  * ')}
 */
export function ${methodName}(${methodArgs.join(', ')}): ${methodResult} {
   ${methodResult ? 'return' : ''}
}

    `;
  }

  let methodOutput: Array<string> = [];
  const { paths } = spec;
  for (let url in paths) {
    for (let method in paths[url]) {
      let mm = paths[url][method];
      methodOutput.push(methodOutputParse(url, method, mm));
    }
  }

  output.push(methodOutput.join('\n'));

  output.push('}'); // Close namespace

  return prettier.format(output.join('\n'), { parser: 'typescript', singleQuote: true });
}

export default parse;
